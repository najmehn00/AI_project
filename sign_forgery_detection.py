# -*- coding: utf-8 -*-
"""Sign_Forgery_Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19DxabzNwdnCPEpY1xMNtMrwuPQoMe1nJ

# Data preprocessing
"""

# ! pip install -q kaggle

# !pip install -q pip Keras-Preprocessing

# from google.colab import files
# files.upload()

# ! mkdir ~/.kaggle/

# ! cp kaggle.json ~/.kaggle/

# ! chmod 600 ~/.kaggle/kaggle.json

# ! kaggle datasets download -d robinreni/signature-verification-dataset

# from zipfile import ZipFile
# file_name = "signature-verification-dataset.zip"
# with ZipFile(file_name, 'r') as zip:
#     print('Extracting all the files now...')
#     zip.extractall()
#     print('Done!')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import tensorflow as tf
import cv2
from tensorflow.keras.layers import Input, Lambda, MaxPooling2D, BatchNormalization, Dense, Flatten, Activation,Convolution2D
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras import optimizers
from tensorflow.keras.utils import plot_model
from tensorflow.keras import backend as K
from tensorflow.keras.utils import to_categorical
import os
from tensorflow.keras.losses import Loss
from keras_preprocessing import image

def read_data(dir, data):
    images1 = []
    images2 = []
    labels = []
    for j in range(0, len(data)):
        path = os.path.join(dir,data.iat[j, 0])
        img1 = cv2.imread(path)
        img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        img1 = cv2.resize(img1, (100, 100))
        images1.append([img1])
        path = os.path.join(dir, data.iat[j, 1])
        img2 = cv2.imread(path)
        img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
        img2 = cv2.resize(img2, (100, 100))
        images2.append([img2])
        labels.append(np.array(data.iat[j, 2]))
    images1 = np.array(images1).astype(np.float32) / 255.0
    images2 = np.array(images2).astype(np.float32) / 255.0
    labels = np.array(labels).astype(np.float32)
    return images1, images2, labels

train_dir = '/content/sign_data/train'
train_csv = '/content/sign_data/train_data.csv'
df_train = pd.read_csv(train_csv, header=None)
train_images1, train_images2, train_labels = read_data(dir=train_dir, data=df_train)
train_labels = to_categorical(train_labels)

size = 100
train_images1 = train_images1.reshape(-1, size, size, 1)
train_images2 = train_images2.reshape(-1, size, size, 1)

print(df_train.iloc[0, :])
img_org = df_train.iloc[0, 0]
img_frg = df_train.iloc[0, 1]

img_original = plt.imread('/content/sign_data/train/'+img_org)
img_forged = plt.imread('/content/sign_data/train/'+img_frg)

print('/content/sign_data/train/'+img_org)

plt.subplots(1, 1, sharex=True, sharey=True)
plt.imshow(img_original)

plt.subplots(1, 1, sharex=True, sharey=True)
plt.imshow(img_forged)

"""# Simple Siamese Network"""

def initialize_base_network(input_shape):
    clf = Sequential()
    clf.add(Convolution2D(64, (3,3),input_shape=input_shape))
    clf.add(Activation('relu'))
    clf.add(MaxPooling2D(pool_size=(2, 2)))
    clf.add(Convolution2D(32, (3,3)))
    clf.add(Activation('relu'))
    clf.add(MaxPooling2D(pool_size=(2, 2)))
    clf.add(Flatten())
    clf.add(Dense(128, activation='relu'))
    clf.add(Dense(64, activation='relu'))
    return clf
def euclidean_distance(vects):
    x, y = vects
    return K.sqrt(K.sum(K.square(x - y), axis=1, keepdims=True))
def eucl_dist_output_shape(shapes):
    shape1, shape2 = shapes
    return (shape1[0], 1)

input_dim = (100, 100, 1)
base_network = initialize_base_network(input_dim)
img_a = Input(shape=input_dim)
img_b = Input(shape=input_dim)
vec_a = base_network(img_a)
vec_b = base_network(img_b)
distance = Lambda(euclidean_distance, output_shape=eucl_dist_output_shape)([vec_a, vec_b])
prediction = Dense(2, activation='softmax')(distance)
model = Model([img_a, img_b], prediction)
model.summary()

adam = tf.keras.optimizers.Adam(lr=0.00008)
model.compile(loss='categorical_crossentropy',optimizer=adam,metrics=['accuracy'])
model.fit([train_images1,train_images2],train_labels,validation_split=.30,batch_size=32,epochs=40)

img_org = df_train.iloc[0, 0]
img_frg = df_train.iloc[0, 1]
img_original = '/content/sign_data/train/'+img_org
img_forged = '/content/sign_data/train/'+img_frg

x = image.load_img(img_original, target_size=(100, 100))
x = image.img_to_array(x)
x = tf.image.rgb_to_grayscale(x)
x = np.expand_dims(x, axis=0)
x = x/255.0

y = image.load_img(img_forged, target_size=(100, 100))
y = image.img_to_array(y)
y = tf.image.rgb_to_grayscale(y)
y = np.expand_dims(y, axis=0)
y = y/255.0
y_pred = model.predict([x,y])
print(y_pred)
y_pred = np.argmax(y_pred)
print(y_pred)

if y_pred==1:
  print('Forged')
else:
  print('Real')

from google.colab import drive
drive.mount('/content/drive')

model.save('/content/drive/MyDrive/signature-forgery-detection-project/weights/model_test.h5')

import keras

loaded = keras.models.load_model("/content/drive/MyDrive/signature-forgery-detection-project/weights/model_test.h5")

img_original = '/content/drive/MyDrive/signature-forgery-detection-project/data/mydata_1/image_1_original.png'
img_forged = '/content/drive/MyDrive/signature-forgery-detection-project/data/mydata_1/image_2_original.png'

x = image.load_img(img_original, target_size=(100, 100))
x = image.img_to_array(x)
x = tf.image.rgb_to_grayscale(x)
x = np.expand_dims(x, axis=0)
x = x/255.0

y = image.load_img(img_forged, target_size=(100, 100))
y = image.img_to_array(y)
y = tf.image.rgb_to_grayscale(y)
y = np.expand_dims(y, axis=0)
y = y/255.0
y_pred = loaded.predict([x,y])
print(y_pred)
y_pred = np.argmax(y_pred)

if y_pred==1:
  print('Forged')
else:
  print('Real')

import os
import itertools


original_path='/content/drive/MyDrive/signature-forgery-detection-project/data/my_data_2/data/original'
forgery_path='/content/drive/MyDrive/signature-forgery-detection-project/data/my_data_2/data/forgery'


def make_pair(file_name_list,flag):

    all_combinations=list(itertools.combinations(file_name_list,2))

    combination_list=[]
    for combination in all_combinations:

        info_1=combination[0].split('_')
        id_1=info_1[0]
        type_1=info_1[1]
        tag_1=info_1[2]

        info_2=combination[1].split('_')
        id_2=info_2[0]
        type_2=info_2[1]
        tag_2=info_2[2]
        print(type_1,type_2)

        if flag=='of':
            if type_1!=type_2 and id_1==id_2 :
                if type_1=='forgery':
                    img_path_1=os.path.join(original_path,combination[1])
                    img_path_2=os.path.join(forgery_path,combination[0])
                else:
                    img_path_1=os.path.join(original_path,combination[0])
                    img_path_2=os.path.join(forgery_path,combination[1])
                combination_list.append((img_path_1,img_path_2))
        elif flag=='oo':
            if id_1==id_2 and tag_1!=tag_2:
                img_path_1=os.path.join(original_path,combination[0])
                img_path_2=os.path.join(original_path,combination[1])
                combination_list.append((img_path_1,img_path_2))

    return combination_list




def compare_signature(img_original,img_suspended,flag,model_path):
    loaded = keras.models.load_model(model_path)



    x = image.load_img(img_original, target_size=(100, 100))
    x = image.img_to_array(x)
    x = tf.image.rgb_to_grayscale(x)
    x = np.expand_dims(x, axis=0)
    x = x/255.0

    y = image.load_img(img_suspended, target_size=(100, 100))
    y = image.img_to_array(y)
    y = tf.image.rgb_to_grayscale(y)
    y = np.expand_dims(y, axis=0)
    y = y/255.0
    y_pred = loaded.predict([x,y])
    y_pred = np.argmax(y_pred)


    if y_pred==1:
        if flag=='of':
            return 1;
        elif flag=='oo':
            return 0
    else:
        if flag=='of':
            return 0
        elif flag=='oo':
            return 1;

forgery_files_name=os.listdir(forgery_path)
original_files_name=os.listdir(original_path)

print('number of original image:...',len(original_files_name))
print('number of forgery image:...',len(forgery_files_name))

oo_pair=make_pair(file_name_list=original_files_name,flag='oo')

len(oo_pair)

oo_points=0
for imgs in oo_pair:
  temp=compare_signature(img_original=imgs[0],img_suspended=imgs[1],flag='oo',model_path='/content/drive/MyDrive/signature-forgery-detection-project/weights/model_test.h5')
  oo_points=temp+oo_points

oo_points

all=original_files_name+forgery_files_name

of_pair=make_pair(file_name_list=all,flag='of')

len(of_pair)

of_points=0
for imgs in of_pair:
  temp=compare_signature(img_original=imgs[0],img_suspended=imgs[1],flag='of',model_path='/content/drive/MyDrive/signature-forgery-detection-project/weights/model_test.h5')
  of_points=temp+of_points

of_points